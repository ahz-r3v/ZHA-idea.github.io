<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZHA-idea</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-17T12:59:01.872Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ahz-r3verse</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/11/CSAPP-ShellLab/"/>
    <id>http://example.com/2021/10/11/CSAPP-ShellLab/</id>
    <published>2021-10-11T07:41:05.251Z</published>
    <updated>2021-10-17T12:59:01.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-ShellLab"><a href="#CSAPP-ShellLab" class="headerlink" title="CSAPP-ShellLab"></a>CSAPP-ShellLab</h1><p>代码：<a href="https://github.com/ZHA-idea/CSAPP_ShellLab">Github</a></p><blockquote><p>这一个lab要求用C语言实现一个完整的shell，感觉主要知识是shell对job的管理和进程间的信号通信。</p></blockquote><h2 id="1-实验介绍"><a href="#1-实验介绍" class="headerlink" title="1. 实验介绍"></a>1. 实验介绍</h2><p>在本次实验中，你将编写一个简单的支持任务控制的Uinx shell程序，本次实验的目的是加深大家对进程控制和信号的理解。</p><p>实验代码的整体框架已经搭建好了，我们的任务是完成其中的某些函数。</p><h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h2><p>控制流(control flow)：CPU执行的指令序列。</p><p>异常控制流(ECF, Exceptional Control Flow)：<strong>系统为了应对系统状态的变化</strong>，使控制流发生突变，这些突变称为异常控制流。</p><p>异常控制流存在于计算机系统的各个层次：</p><ul><li><p>底层：</p></li><li><ul><li>异常(Exceptions)，更改控制流以应对某个系统事件，由硬件和操作系统共同实现。</li></ul></li><li><p><img src="http://pic.zha-node.com/uploads/big/b4cbb663d9d5a0e83f386a542c63f6f8.png"></p></li><li><ul><li>异常的分类</li></ul></li><li><p><img src="http://pic.zha-node.com/uploads/big/d0db8d22eb5acd2c2dd6e65631a8d917.png"></p></li><li><p>顶层：</p></li><li><ul><li>进程切换：由操作系统和硬件时钟共同实现</li><li>信号：由操作系统实现</li><li>非本地跳转：由C库实现</li></ul></li></ul><h3 id="2-1-C库函数"><a href="#2-1-C库函数" class="headerlink" title="2.1 C库函数"></a>2.1 C库函数</h3><ul><li>获取进程pid</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//获取父进程pid</span></span><br></pre></td></tr></table></figure><ul><li>创建和终止进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>回收子进程（P516</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-Linux信号"><a href="#2-2-Linux信号" class="headerlink" title="2.2 Linux信号"></a>2.2 Linux信号</h3><p>它通知进程系统中发生了一个某种类型的事件，在终端，可以通过<code>kill -l</code>查看所有信号</p><ul><li>类似于异常和中断</li><li>由操作系统内核发送给进程</li></ul><h5 id="2-3-1-信号的发送-（P529"><a href="#2-3-1-信号的发送-（P529" class="headerlink" title="2.3.1. 信号的发送 （P529"></a>2.3.1. 信号的发送 （P529</h5><p>内核通过<strong>更新目标进程的某些状态</strong>来发送一个信号给目标进程。</p><p>内核发送信号可能由于以下几种原因：</p><ul><li>内核检测到了某个系统事件的发生</li><li>另外某个进程调用kill系统调用，要求内核给目标进程发送一个信号</li></ul><h5 id="2-3-2-信号的接收-（P531"><a href="#2-3-2-信号的接收-（P531" class="headerlink" title="2.3.2. 信号的接收 （P531"></a>2.3.2. 信号的接收 （P531</h5><p>信号接受的时机：</p><p>当内核把进程p<strong>从内核模式切换到用户模式时</strong>，它会检查进程p的未被阻塞的待处理信号的集合(pending &amp; ~blocked)，如果集合为空，内核将控制传递到p的逻辑流中的下一条指令。然而，如果集合非空，那么内核将选择集合中的某个信号k并且强制p接收信号k。</p><p><img src="http://pic.zha-node.com/uploads/big/7ab9c92e8b5f031da61cc82f66325116.png" alt="img"></p><p>每个信号都有一个预定义的默认行为，进程可以使用signal函数可以修改和信号关联的默认行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span></span><br></pre></td></tr></table></figure><h5 id="2-3-3-信号的阻塞-（P533"><a href="#2-3-3-信号的阻塞-（P533" class="headerlink" title="2.3.3. 信号的阻塞 （P533"></a>2.3.3. 信号的阻塞 （P533</h5><p>隐式阻塞：内核默认阻塞当前正在处理的信号</p><p>显式阻塞：进程可以使用<strong>sigprocmask函数</strong>明确地阻塞和解除阻塞选定的信号</p><p>某个信号s被阻塞后，进程可以接收别的进程发送来的s信号，但是暂时不对s信号进行相应。</p><h3 id="2-3-Shell行为"><a href="#2-3-Shell行为" class="headerlink" title="2.3 Shell行为"></a>2.3 Shell行为</h3><p>Shell 本身是一个进程，用于代理用户与操作系统内核。</p><p>Shell 建立并维护一个 Jobs 列表，Jobs 列表中维护“作业”（Job），每个作业与一个进程对应，并用 jid 唯一标识。与进程不同的是，Jobs 由 shell 维护，它定义了作业能够存在的几种状态：Running、Stopped、Terminated。</p><p>当shell执行外部命令时，shell调用fork函数并在子进程中执行新进程，因此，所有在shell中调用的命令都是shell的子进程</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>代码：<a href="https://github.com/ZHA-idea/CSAPP_ShellLab">Github</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSAPP-ShellLab&quot;&gt;&lt;a href=&quot;#CSAPP-ShellLab&quot; class=&quot;headerlink&quot; title=&quot;CSAPP-ShellLab&quot;&gt;&lt;/a&gt;CSAPP-ShellLab&lt;/h1&gt;&lt;p&gt;代码：&lt;a href=&quot;https://gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP-AttackLab</title>
    <link href="http://example.com/2021/09/17/CSAPP_AttackLab/"/>
    <id>http://example.com/2021/09/17/CSAPP_AttackLab/</id>
    <published>2021-09-17T09:56:59.000Z</published>
    <updated>2021-09-20T07:17:52.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-AttackLab"><a href="#CSAPP-AttackLab" class="headerlink" title="CSAPP-AttackLab"></a>CSAPP-AttackLab</h1><p>WriteUp:<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">http://csapp.cs.cmu.edu/3e/attacklab.pdf</a></p><blockquote><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>第一部分：代码注入攻击 对于前三个阶段，您的漏洞利用字符串将攻击 CTARGET。 该程序的设置方式使堆栈位置从一次运行到下一次运行保持一致，因此可以将堆栈上的数据视为可执行代码。 这些功能使程序容易受到攻击，其中漏洞利用字符串包含可执行代码的字节编码。 </p><p>第二部分：面向返回的编程<br>对程序 RTARGET 执行代码注入攻击比 CTARGET 困难得多，因为它使用两种技术来阻止此类攻击。</p><h2 id="使用-HEX2RAW"><a href="#使用-HEX2RAW" class="headerlink" title="使用 HEX2RAW"></a>使用 HEX2RAW</h2><p>HEX2RAW 将十六进制格式的字符串作为输入。 在这种格式中，每个字节值由两个十六进制数字表示。 例如，字符串“012345”可以以十六进制格式输入为“30 31 32 33 34 35 00”。 （回想一下十进制数字 x 的 ASCII 码是 0x3x，并且字符串的结尾由空字节表示。） 您传递给 HEX2RAW 的十六进制字符应由空格（空格或换行符）分隔。 我们建议您在处理漏洞时用换行符分隔漏洞利用字符串的不同部分。 HEX2RAW 支持 C 风格的块注释，因此您可以标记出漏洞利用字符串的部分。 例如：</p><p> <code>48 c7 c1 f0 11 40 00 /* mov $0x40011f0,%rcx */</code></p><p>确保在开始和结束注释字符串（“/<em>”、“</em>/”）周围都留有空格，以便正确忽略注释。</p></blockquote><p><strong>ADVICE: Include the -q flag which prevents program from contacting non-existent grading server in addition to the above</strong></p><h2 id="Phase1"><a href="#Phase1" class="headerlink" title="Phase1"></a>Phase1</h2><blockquote><p>For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute an existing procedure.</p></blockquote><p>这一部分仅利用缓冲区溢出，getbuf函数要求输入一行字符串，要让这行字符串溢出到上一个栈帧的返回地址区域，就能使得本该返回 main 的程序跳转到 touch1 的代码。</p><p>主要有两个知识点：</p><ul><li>栈的结构</li><li>hex 与 字符串 的相互转化</li></ul><h5 id="栈的结构："><a href="#栈的结构：" class="headerlink" title="栈的结构："></a>栈的结构：</h5><p>字符串以倒着的顺序，从栈顶往栈底存储.字符占用1<code>byte</code>空间，也就是8个<code>bit</code>位。在栈中，地址指的是byte，每个地址有8bit的存储空间，两个16进制数表示一个byte的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个16进制数 = 8bit = 1byte = 一个地址空间</span><br></pre></td></tr></table></figure><p>一个地址占用 8 byte 空间，这也解释了为什么有些函数并没有向栈中暂存数据，但也要申请至少8字节的栈空间。</p><p>查了一下google，这个专业名词叫栈的8字节对齐，能够提高程序运行效率</p><h5 id="hex2raw："><a href="#hex2raw：" class="headerlink" title="hex2raw："></a>hex2raw：</h5><p>栈中存储的是16进制数（hex），但是函数输入是字符串形式，这时候就需要找到两者之间的映射关系。比如这一题里需要覆写的hex为<code>40 17 c0</code>，40好办，因为hex to raw的逻辑与ascii码相容，0x40的ascii码是@。</p><p>但是17就比较难办了，因为ascii码中17没有显式的字符与之对应，也就是说键盘输入hex为17的字符是不现实的。这个时候只能用lab中自带的hex2raw来完成这个工作。虽然17的字符不能显式表达，但是它确实存在。</p><p>命令行输入</p><p><code>cat hex.txt | ./hex2raw | ./ctarget -q</code>（-q是指不给csapp的服务器发送信息）</p><p>就能把hex.txt中的16进制数通过hex2raw转化成字符串形式输入进ctarget程序。</p><p>⚠️注意字符串的存储是倒着来的（至少这一题中是的），所以地址也要倒着写。hex.txt内容如下：</p><p><img src="http://zha.glimmer.space/uploads/medium/fecf106158cd9cdc822c16c362aeafd5.png"></p><p>✅phase1通过：</p><p><img src="http://zha.glimmer.space/uploads/medium/3dadc3f395d07a87997514c4803c0083.png"></p><h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><blockquote><p>Phase 2 involves injecting a small amount of code as part of your exploit string.</p></blockquote><p>phase2是phase1的进阶版，要在重定向的基础上，实现一个数据注入。</p><p>思路是在两个函数中加插入一个函数，这个函数的bin代码放在栈上（此题中实际是堆），</p><p>⚠️注意%rip以地址递增读取，返回值以地址递减读取（想象pop出栈），同一个地址内从左到右。</p><p><img src="http://zha.glimmer.space/uploads/big/469280424922c6d42683dc9bbbd91646.png"></p><p>内存栈入口位置：0x5561dc78</p><h2 id="Phase3"><a href="#Phase3" class="headerlink" title="Phase3"></a>Phase3</h2><p>和Phase2大同小异，只不过是吧参数换成字符串形式存储在栈上，rdi寄存器里面放着个字符串的地址，</p><p>要注意的是getbuf函数的栈帧在释放之后，可能会有后续的栈帧来覆盖这一部分。经过试验如果在缓冲区的40个字节里面放字符串，会被覆盖掉。</p><p><img src="http://zha.glimmer.space/uploads/big/9a4da539d1971562c69b4dc3218bec5d.png"></p><h2 id="Phase4"><a href="#Phase4" class="headerlink" title="Phase4"></a>Phase4</h2><p>事情开始变得有意思起来了，这一部分开始，就要用到<strong>面向返回编程</strong>（ROP）的思想进行攻击了。先来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4019b5:    c7 07 48 89 c7 90    movl  $0x90c78949,(%rdi)</span><br><span class="line">4019c9:    c3                   ret</span><br></pre></td></tr></table></figure><p>单凭这一句汇编来讲，好像没有什么值得利用的地方，但是注意movl这一句这里：<code>48 89 c7</code>，如果放在movl这一句里面表示的仅仅是一个立即数而已，但是如果把<code>48 89 c7</code>看作是操作指令的话，它代表的意思就是:<code>mov  %rax,%rdi</code>。仔细想想，如果利用这一点，是不是感觉操作空间很大了呢？（只能说，舞台很大</p><img src="http://zha.glimmer.space/uploads/big/3aadccc646f4782ce724bf862ecf7238.webp" style="zoom: 33%;" /><p>至于一些常见指令的二进制表达，在writeUp里面也有提到，如下图：</p><p><img src="http://zha.glimmer.space/uploads/medium/d140900993a3c982e6bf5a3039c5fbf6.png"></p><p>既然是<strong>面向返回编程</strong>，就要对汇编中出现的<code>c3(ret) </code>和<code>90(nop)</code>敏感，这些往往是思路的切入点。</p><p>题解就不放了，知道了这些很简单。</p><h5 id="⚠️另外要注意：大端序和小端序，这题里面的数据都是小端序摆放的，且占8个字节，多余的用00填充"><a href="#⚠️另外要注意：大端序和小端序，这题里面的数据都是小端序摆放的，且占8个字节，多余的用00填充" class="headerlink" title="⚠️另外要注意：大端序和小端序，这题里面的数据都是小端序摆放的，且占8个字节，多余的用00填充"></a>⚠️另外要注意：大端序和小端序，这题里面的数据都是小端序摆放的，且占8个字节，多余的用00填充</h5><h2 id="Phase5"><a href="#Phase5" class="headerlink" title="Phase5"></a>Phase5</h2><p><del>不想写了，就这吧</del></p><p>这一部分也是ROP攻击，思路和Phase4一样，但是因为要传字符串，难度会比Phase4高不少，so，不写了，<strong>摸鱼了🐟</strong></p><h1 id="下次一定下次一定😅"><a href="#下次一定下次一定😅" class="headerlink" title="下次一定下次一定😅"></a>下次一定下次一定😅</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSAPP-AttackLab&quot;&gt;&lt;a href=&quot;#CSAPP-AttackLab&quot; class=&quot;headerlink&quot; title=&quot;CSAPP-AttackLab&quot;&gt;&lt;/a&gt;CSAPP-AttackLab&lt;/h1&gt;&lt;p&gt;WriteUp:&lt;a href=&quot;h</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="http://example.com/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-BombLab</title>
    <link href="http://example.com/2021/09/16/CSAPP-BombLab/"/>
    <id>http://example.com/2021/09/16/CSAPP-BombLab/</id>
    <published>2021-09-16T09:56:59.000Z</published>
    <updated>2021-09-17T12:10:25.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-BombLab：拆包战士"><a href="#CSAPP-BombLab：拆包战士" class="headerlink" title="CSAPP-BombLab：拆包战士"></a>CSAPP-BombLab：拆包战士</h1><blockquote><p>最近在做csapp的实验，刚做完datalab（还差浮点数部分的三道）感觉自己智商不够用。bomblab更是震撼我妈一百年，先不说要看反汇编代码，光是调试工具什么<code>gdb</code>我都不会用。害，当然是要从头学习了</p></blockquote><p>BombLab题目是说有 one 个 Evil 人 create 了一个 bomb，这个 bomb 总共有6道 phase，要work out完所有的六道 phase 才能 defuse 炸弹。</p><h2 id="Phase1"><a href="#Phase1" class="headerlink" title="Phase1"></a>Phase1</h2><p>看汇编代码上来就把<code>0x402400</code>塞到了<code>%esi</code>里，显然这是一个十六进制数，是内存地址的可能性非常大。而反汇编代码程序区的最高地址位是<code>0x4022ac</code>，那么根据C语言内存结构来看：</p><p><img src="http://zha.glimmer.space/uploads/big/799ddf696ca3e31b3154505811d18879.png"></p><p>这个地址很可能是常量，在gdb中使用<code>x /s 0x402400</code>查看这个地址的常量。</p><p><img src="http://zha.glimmer.space/uploads/big/13c6e3c0969c02ed6300fa01a90527df.png"></p><p>第一个Phase的答案就是这行字符串</p><p><code>Border relations with Canada have never benn better.</code></p><blockquote><p>gdb指令x表示查看内存内容，/s表示以字符串形式查看</p></blockquote><h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><blockquote><p>gdb的另一个指令“layout regs”可以显示寄存器中的值</p></blockquote><p>从这部分开始，不会用gdb就真的做不出来了<del>（我们gdb真是绝绝子啊</del></p><p>首先注意到<code>phase_2</code>的函数调用了一个名叫<code>read_six_numbers</code>的函数，顾名思义是读入了6个整数。于是测试一下，在第二行输入<code>1 2 3 4 5 6</code>测试，并且用gdb -layout regs边看寄存器地址边调试，发现输入的6个数据被存储在了<code>%rsp</code>附近。(具体为什么存在栈里而不是寄存器里，可能就要看read_line了，我不想看)</p><p>然后<code>phase_2</code>的代码里面有一段循环，大概意思是<code>%rbx</code>每次+4，直到<code>%rbp=%rbx</code>时候跳出循环，循环内容是<code>%eax</code>值每次*2并与栈中数字比较。<code>0x400f0a</code>这一行可以看出第一个值是1，因此答案是<code>1 2 4 8 16 32</code></p><blockquote><p>别看写的少，做题好难哦</p><p>思考：以这一题里的例子，for循环计数的一种实现方法可以是用 rbx 和 rbp 两个寄存器来实现。</p></blockquote><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>在程序运行的每个阶段，只需要栈中一部分的数据（一般就是最下面那一段）。栈帧用来记录调用未返回的位置，同时也能标记正在运行的过程栈的边界。<code>%rbp</code> 被称为基指针(Optional)</p><img src="http://zha.glimmer.space/uploads/medium/6404ac9ffd50983ac61c822b740b95b1.png" style="zoom: 33%;" /><blockquote><p><strong>为什么%rbp是optional的？</strong></p><p>对于一般的程序来说，编译器在编译时能够知道被调用的过程所需要的确切的栈的大小，比如18个比特，然后在栈释放的时候只需要释放同样的数值即可。此时无需**%rbp**。</p><p>但是有些时候编译器无法提前预知栈的大小，比如可变数组或内存缓冲区，此时必须要用到**%rbp**</p></blockquote><h4 id="lea？好怪哦"><a href="#lea？好怪哦" class="headerlink" title="lea？好怪哦"></a>lea？好怪哦</h4><h6 id=""><a href="#" class="headerlink" title=""></a><img src="http://zha.glimmer.space/uploads/big/b383debc45dc2c3b3749603ef7f65735.jpeg" style="zoom:25%;" /></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq8(%rsp), %rdi</span><br></pre></td></tr></table></figure><p>按理说加括号代表取这个地址的值吧，那应该翻译成 “ 把内存中<code>%rsp+8</code>位置的值赋给<code>%rdi</code> ” ；但是leaq怪得很，他不读内存，这句的意思是 “ 把<code>%rsp</code>的值+8赋给<code>%rdi</code> ” </p><blockquote><p><strong>这样的话LEA与ADD有啥子区别吗？</strong></p><p>LEA由处理寻址的单元之一(在流水线的早期发生)，而ADD则进入ALU(算术/逻辑单元) ，以及后期发生。</p><p>地址计算发生在流水线的前期，没有必要去使用成本更高的ADD指令。况且LEA指令除了做加法，也能简便地表示乘法与位移。</p></blockquote><h2 id="Phase3"><a href="#Phase3" class="headerlink" title="Phase3"></a>Phase3</h2><p>做着做着感觉渐入佳境了，上来看到0x4025cf，二话不说<code>gdb: x /s 0x4025cf</code>，发现这个地方是两个整数占位符，那这题可能就是要输入两个整数咯。</p><p>然后看到要用到rsp，于是用<code>gdb</code>缓缓打出一个<code>break *0x400f6a</code>设置断点，再拿<code>layout regs</code><del>做一个隐藏甜品778</del>，康康寄存器是什么东西。发现<code>%rsp+8</code>的位置其实是我输入的第一个数据，于是乎<strong>第一个数据需要&lt;7</strong>，这个条件就出来了，顺手查出第二个数据存储在<code>%rsp+12</code>。<del>我们gdb真的是绝绝子呀，好用到跺jiojio！</del></p><p>然后一顿操作答案就出来了：<code>1 311</code></p><blockquote><p>gdb x用法</p><p>用gdb查看内存</p><p>格式: x /nfu <addr></p><p>说明<br>x 是 examine 的缩写</p><p>n表示要显示的内存单元的个数</p><p>f表示显示方式, 可取如下值<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>i 指令地址格式<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。</p><p>u表示一个地址单元的长度<br>b表示单字节，<br>h表示双字节，<br>w表示四字节，<br>g表示八子节</p></blockquote><h2 id="Phase4"><a href="#Phase4" class="headerlink" title="Phase4"></a>Phase4</h2><p>Halfway there!</p><p>点开phase_4的代码，一眼看到熟悉的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea    0xc(%rsp),&amp;rcx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea    0x8(%rsp),%rdx</span><br></pre></td></tr></table></figure><p>肯定两个参数是存储在这个地方的（<del>能不能有点新意啊好简单哦</del></p><p>然后那个看不太明白的函数<code>400bf0 &lt;__isoc99_sscanf@plt&gt;</code>，根据推测应该是将输入的参数<strong>个数</strong>赋值给<code>%eax</code>，也就是说这题依然是需要两个参数。</p><p>正当我轻轻松松看汇编代码的时候，眼看phase_4就要被破解了，突然它一个转身拐进了另一个函数<func_4>。       <img src="http://zha.glimmer.space/uploads/big/77340769caf19fd29b914a7d18383b9d.jpeg" style="zoom: 25%;" /></p><p>仔细观摩了代码之后发现除非<code>x = 7</code>，否则会陷入一圈又一圈的循环，跳出循环后，需要<code>y = 0</code></p><p>综上，第四题答案是<code>7 0</code></p><p>总感觉。。。大的要来力！</p><h2 id="Phase5"><a href="#Phase5" class="headerlink" title="Phase5"></a>Phase5</h2><p>看到了一个没见过的东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    %fs:0x28,%rax</span><br><span class="line">mov    %rax,0x18(%rsp)</span><br></pre></td></tr></table></figure><p>这个应该是<code>金丝雀值</code>，使用段寻址把金丝雀值放到<code>rsp+18</code>位置，然后用xor校验，对解题没啥大的影响。</p><p>总的来说逻辑是要输入一个字符串，字符串长度必须是六个字符，然后和内存中<code>0x40245e</code>位置的字符串比较，相同的话就能通过。简简单单<code>x /s 0x40245e</code>发现这个地方的字符串是<code>flyers</code>。于是我兴冲冲填上flyers，发现炸弹还是炸了。</p><p>怪！</p><p>用gdb仔细调试了一波发现，这段代码会把输入的字符串加密，比如我输入的 flyers，经过加密就变成了 rvfedu 这串怪字符，这该咋办。我试着输入其他的字符串，然后看看加密后的结果。最终我发现字符串的加密很可能是一一映射的，于是我想了一个笨方法，只要找到能够映射到 flyers 的字符不就好了吗？暴力破解一通，找到了如下映射。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">y</span> : <span class="string">f</span></span><br><span class="line"><span class="attr">o</span> : <span class="string">l</span></span><br><span class="line"><span class="attr">n</span> : <span class="string">y</span></span><br><span class="line"><span class="attr">e</span> : <span class="string">e</span></span><br><span class="line"><span class="attr">f</span> : <span class="string">r</span></span><br><span class="line"><span class="attr">g</span> : <span class="string">s</span></span><br></pre></td></tr></table></figure><p>输入 yonefg 运行，测试通过！</p><p>这题到这好像完了，又好像没完，这个加密的逻辑到底是啥，等我做完phase6先</p><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p>前面做题也差不多知道了，栈底的地址是<code>0x7fffffffffff</code>，转化成二进制也就是47个1。x86-64机器限制内存只用64位中的47位，即使这样也有大约128TB容量。（当然这是虚拟内存，实际内存肯定没有那么大）</p><ul><li><p>栈（Stack）：从<code>0x7fffffffffff</code>向下增长，最大8MB。</p></li><li><p>堆（Heap）：低至<code>0x600000</code>附近，高至栈附近，都是堆的可能空间，堆既可以从<code>0x600000</code>附近向上增长，也可以从栈附近向下增长。</p></li><li><p>Data：存放静态变量 </p></li><li><p>Text：存放编译后的机器代码，起点是<code>0x400000</code></p></li></ul><h2 id="Phase6"><a href="#Phase6" class="headerlink" title="Phase6"></a>Phase6</h2><p>这提和Phase1一样，都调用了“读六个数”函数</p><ol><li>共要有等于6个参数</li><li>每个参数在1～6之间</li><li>参数间两两不能相同</li><li>会把参数顺序反过来</li></ol><p> 在看内存的时候，发现有一块位置标记为“node1”，而且这个node1的大小是两个整数的长度，很奇怪。不过接着往下看，发现像node1一样的内存位置一共有6个，而且每个node的后8位看起来像是地址。。。写出来是这样式的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">节点数据区地址位</span><br><span class="line">node1:0x14c</span><br><span class="line">node2:0xa8</span><br><span class="line">node3:0x39c</span><br><span class="line">node4:0x2b3</span><br><span class="line">node5:0x1dd</span><br><span class="line">node6:0x1bb</span><br></pre></td></tr></table></figure><p>node。。。地址。。。这玩意不会是链表吧！</p><p>果然这玩意还真是链表，输入的六个数字，规定了这6个节点的链接顺序，妙。而为了解决问题，这六个节点的前八个字节，也就是数据区必须以从大到小的顺序排列，那么就是3-4-5-6-1-2的顺序。填入3-4-5-6-1-2，Boom！炸了。经过第五题的洗礼我突然意识到这个逼题可能也有加密，尝试了多种加密方法后，发现他的加密逻辑是<code>7-输入的数字</code>，那么答案就是5-6-1-2-3-4，测试通过！</p><p><img src="http://zha.glimmer.space/uploads/big/0eed51dd29ecfcfdd418610ada34caf7.png"></p><h6 id="什么？phase5的加密逻辑？你说什么我听不懂啊～XD"><a href="#什么？phase5的加密逻辑？你说什么我听不懂啊～XD" class="headerlink" title="什么？phase5的加密逻辑？你说什么我听不懂啊～XD"></a><del>什么？phase5的加密逻辑？你说什么我听不懂啊～XD</del></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSAPP-BombLab：拆包战士&quot;&gt;&lt;a href=&quot;#CSAPP-BombLab：拆包战士&quot; class=&quot;headerlink&quot; title=&quot;CSAPP-BombLab：拆包战士&quot;&gt;&lt;/a&gt;CSAPP-BombLab：拆包战士&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="http://example.com/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql &amp; JDBC noob</title>
    <link href="http://example.com/2021/04/12/Mysql-JDBC-noob/"/>
    <id>http://example.com/2021/04/12/Mysql-JDBC-noob/</id>
    <published>2021-04-12T11:25:10.000Z</published>
    <updated>2021-04-12T11:33:58.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习MySql数据库-和-JDBC"><a href="#学习MySql数据库-和-JDBC" class="headerlink" title="学习MySql数据库 和 JDBC"></a>学习MySql数据库 和 JDBC</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h3 id="一、终端登录数据库"><a href="#一、终端登录数据库" class="headerlink" title="一、终端登录数据库"></a>一、终端登录数据库</h3><p><a href="https://www.bilibili.com/video/BV1Vt411z7wy">一天学会mysql</a></p><p>配置环境变量略</p><h4 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h4><p><strong>登陆：<code>&gt;mysql -uroot -p********</code></strong></p><blockquote><p>-u是usr的意思，-p是psw</p></blockquote><p><strong>查询：<code>mysql&gt; show databases;</code> <code>mysql&gt; show tables;</code></strong></p><p><strong>选中/查询：<code>use xxx</code> <code>mysql&gt; select * from admin</code></strong></p><p>退出：<code>mysql&gt; exit</code></p><p><strong>创建数据库：<code>mysql&gt; create database xxx </code></strong> ``</p><p><strong>创建数据表(example)：<code>CREATE TABLE pet(name VARCHAR(20),owner VARCHAR(20),sex CHAR(1),birth DATE, death DATE); </code></strong></p><p>​        <strong>描述数据表：<code>describe pet/desc pet;</code></strong></p><p>![截屏2021-03-26 上午9.00.29](/Users/boxizhou/Desktop/md/img/截屏2021-03-26 上午9.00.29.png)</p><p><strong>添加数据：<code>INSERT INTO pet</code> <code>VALUES(&#39;Puffball&#39;,&#39;Diane&#39;,&#39;f&#39;,&#39;1999-03-30&#39;,NULL)</code></strong></p><p>![截屏2021-03-26 上午9.07.26](/Users/boxizhou/Desktop/md/img/截屏2021-03-26 上午9.07.26.png)</p><p><strong>删除数据：<code>delete from pet where name=&#39;Puffball&#39; </code></strong>(两条都被删掉)</p><p><strong>修改数据：<code>update pet set name=&#39;Bufferball&#39; where name=&#39;Puffball&#39; </code></strong></p><blockquote><p>增：INSERT</p><p>删：DELETE</p><p>改：UPDATE</p><p>查：SELECT</p></blockquote><h4 id="数据类型：（菜鸟文档）"><a href="#数据类型：（菜鸟文档）" class="headerlink" title="数据类型：（菜鸟文档）"></a>数据类型：（<a href="https://www.runoob.com/mysql/mysql-data-types.html">菜鸟文档</a>）</h4><ol><li>数值（溢出会报错）</li><li>日期/时间</li><li>字符串/字符</li></ol><h4 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h4><ol><li><p>主件约束</p></li><li><p>自增约束</p></li><li><p>唯一约束</p></li><li><p>非空约束</p></li><li><p>默认约束</p></li><li><p><strong>外键约束</strong></p></li></ol><blockquote><p>添加约束</p><ol><li>建表的时候添加约束</li><li>alter 。。。 add 。。。添加约束</li><li>alter。。。modify。。。</li></ol><p>删除约束</p><p>alter 。。。 drop。。。</p></blockquote><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p>– 涉及到两个表：主表，副表</p><p><em><strong>e.g.</strong></em></p><p>主表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table classes(</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>副表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table student(</span><br><span class="line">    id int primary key,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  class_id int,</span><br><span class="line">  foreign key(class_id) references classes(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>⬆️student 表里的 class_id 必须来自于 classes 表中的 id 字段</p><blockquote><p>1 主表 classes 中没有的数据值 ID ，在副表 student 中 class_id 是不可以使用的</p><p>![](/Users/boxizhou/Desktop/md/img/截屏2021-03-27 下午3.30.27.png)</p><p>2 主表中的记录被副表引用，是不可以被删除的</p><p>![](/Users/boxizhou/Desktop/md/img/截屏2021-03-27 下午3.29.24.png)</p></blockquote><h4 id="数据表设计范式"><a href="#数据表设计范式" class="headerlink" title="数据表设计范式"></a>数据表设计范式</h4><h5 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h5><p>字段尽量拆分，数据原子化储存</p><h5 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a><a href="https://www.bilibili.com/video/BV1Vt411z7wy?p=17&spm_id_from=pageDriver">第二范式 2NF</a></h5><p>满足 1NF 前提下，要求除了主建外每一列都必须完全依赖于主键</p><h5 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a><a href="https://www.bilibili.com/video/BV1Vt411z7wy?p=18&spm_id_from=pageDriver">第三范式 3NF</a></h5><p>满足第二范式前提下，除主建外其他列不能有传递依赖关系</p><h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><p><em>典中典：</em><code>select * from xxx</code>;</p><p><em>查询特定字段</em> <code>select sno,cno,degree from student</code></p><p><em>排除重复字段 distinct</em> <code>select distinct * from student</code></p><p><em>区间查询 where …between ..and ..</em> <code>select * from score where degree between 60 and 80</code></p><p>​                                                    <code>select * from score where degree &gt; 60 and degree &lt; 80</code></p><p><em>“in或者“关系查询 in</em><code>select * from score where degree in(85,86,88)</code>(查询score表中成绩为85 86 88的记录)</p><p><em>“or或者”关系查询 or：</em><code>select * from student where class=&#39;95031&#39; or ssex=&#39;女&#39;</code>;（查询 班级是95031 或者 性别是女 的记录）</p><p><em>升序 asc、降序 desc|order by xxx asc/desc：</em><code>select * from student order by clss desc</code> ;</p><p><em>统计个数 count（）：</em><code>select count(*) from student where class=&#39;95031&#39;</code>;</p><h3 id="二、JDBC-Java-DataBase-Connectivity"><a href="#二、JDBC-Java-DataBase-Connectivity" class="headerlink" title="二、JDBC ( Java DataBase Connectivity)"></a>二、JDBC ( Java DataBase Connectivity)</h3><p><a href="https://www.bilibili.com/video/BV1eJ411c7rf"><del>电子科技大学</del>❌尚硅谷大学✅</a></p><p><img src="/Users/boxizhou/Desktop/md/img/JDBC%E6%8A%BD%E8%B1%A1.png" alt="JDBC抽象"></p><h4 id="一、测试数据库连接"><a href="#一、测试数据库连接" class="headerlink" title="一、测试数据库连接"></a>一、测试数据库连接</h4><p><strong>方式一：一步步来</strong></p><p><a href="https://www.runoob.com/mysql/mysql-data-types.html">properties类</a></p><blockquote><p>关于url：</p><p>jdbc:mysql是协议类型</p><p>3306是mysql端口号</p><p>test指其中的名为 test 的数据库</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionTest1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="comment">//1. 获取driver的实现类对象</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line">                <span class="comment">//2. 连接路径</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">          <span class="comment">//3. 这个properties用于封装用户名和密码</span></span><br><span class="line">        Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">          info.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;ZHOUboxi&quot;</span>);</span><br><span class="line">                <span class="comment">//4. 点火起飞</span></span><br><span class="line">        Connection conn = driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">          System.out.println(conn);</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>![截屏2021-03-27 下午8.19.08](/Users/boxizhou/Desktop/md/img/截屏2021-03-27 下午8.19.08.png)</p><p><strong>拿到了数据库，操作成功！</strong></p><p>另外那一串红色的提示说com.mysql.jdbc.Driver不推荐使用，最新的是com.mysql.chj.Driver</p><p><strong>方式二：反射</strong>  增加了可移植性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionTest2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//1。获取Driver的实现类对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver)clazz.newInstance();</span><br><span class="line">        <span class="comment">//2.提供数据库地址</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">        <span class="comment">//3.提供用户名密码</span></span><br><span class="line">        Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">        info.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;ZHOUboxi&quot;</span>);</span><br><span class="line">        <span class="comment">//4.获取连接</span></span><br><span class="line">        Connection conn = driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>方式三：使用DriverManager替换Driver</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionTest3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver)clazz.newInstance();</span><br><span class="line">        <span class="comment">//2.提供三个基本信息</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String pswd = <span class="string">&quot;ZHOUboxi&quot;</span>;</span><br><span class="line">        <span class="comment">//3.注册驱动管理</span></span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line">        <span class="comment">//4.获取连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url,user,pswd);</span><br><span class="line"></span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>方式四：优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionTest4</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line"><span class="comment">/*        Class clazz = **/</span> Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//        Driver driver = (Driver)clazz.newInstance();</span></span><br><span class="line">        <span class="comment">//2.提供三个基本信息</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String pswd = <span class="string">&quot;ZHOUboxi&quot;</span>;</span><br><span class="line"><span class="comment">//        //3.注册驱动管理</span></span><br><span class="line"><span class="comment">//        DriverManager.registerDriver(driver);</span></span><br><span class="line">        <span class="comment">//4.获取连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url,user,pswd);</span><br><span class="line"></span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和三相比，没有去注册driver，因为在加载“com.mysql.jdbc.Driver”类的时候，自动加载了Driver</p><p>Driver实现类代码如下：</p><p>![截屏2021-03-27 下午9.18.13](/Users/boxizhou/Desktop/md/img/截屏2021-03-27 下午9.18.13.png)</p><p>看看这个static代码块，<strong>随着类的加载而加载</strong></p><p><strong>方式五：最终版本，使用配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//todo：把4个基本信息放在配置文件中，读取配置文件获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionTest5</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//1。读取配置文件信息</span></span><br><span class="line">        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line">        <span class="comment">//2.加载驱动</span></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line">        <span class="comment">//3.获取连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置文件：jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取4个基本信息</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">ZHOUboxi</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>好就好在把代码无关的配置<strong>解耦合</strong>了，以后修改时不需要重新打包</p><h4 id="二、PreparedStatement对数据库进行CRUD操作"><a href="#二、PreparedStatement对数据库进行CRUD操作" class="headerlink" title="二、PreparedStatement对数据库进行CRUD操作"></a>二、PreparedStatement对数据库进行CRUD操作</h4><h6 id="三体文明发来信息：不要用Statement！不要用Statement！！不要用Statement！！！"><a href="#三体文明发来信息：不要用Statement！不要用Statement！！不要用Statement！！！" class="headerlink" title="三体文明发来信息：不要用Statement！不要用Statement！！不要用Statement！！！"></a>三体文明发来信息：不要用Statement！不要用Statement！！不要用Statement！！！</h6><p>因为可能会出现sql注入问题，<strong>使用更先进的，有预编译功能的PreparedStatement</strong></p><p>statement翻译为“信使”</p><p>实际上一个数据库连接就是一个<strong>Socket</strong>连接</p><p>为了方便已经把connection操作和最后的资源回收操作封装在JDBCutils类中</p><p><strong>INSERT</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo:增加一条数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//1.建立连接</span></span><br><span class="line">            conn = JDBCutils.getConnection();</span><br><span class="line">            <span class="comment">//2.预编译sql语句，返回PreparedStatement实例</span></span><br><span class="line">            String sql = <span class="string">&quot;insert into user_table(user,password) values(?,?)&quot;</span>;<span class="comment">// 其中&quot;?&quot;是占位符</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//3.填充占位符</span></span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;耐克&quot;</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>,<span class="string">&quot;gaisi&quot;</span>);</span><br><span class="line">            <span class="comment">//4.执行sql操作</span></span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//5.关闭Statement和连接</span></span><br><span class="line">            JDBCutils.closeResuorses(conn,ps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>DELETE、UPDATE</strong>操作类似不再赘述</p><p>下面把增删改放在一起实现</p><blockquote><p>JAVA可变形参的使用：<code>数据类型 ...形参名</code></p><p>只要在形参的数据类型与参数名之间加上三个“.”，就可以让他和个数不确定的实参想匹配。不过有一点需要注意，每个方法<em><strong>只能有一个</strong></em>这样的参数个数可变的形参，且这个形参<em><strong>必须是形参列表的最后一个</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAgrs</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       TestAgrs t = <span class="keyword">new</span> TestAgrs();</span><br><span class="line">       t.sayHello1(<span class="string">&quot;g&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;fg&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如下三个方法构成重载</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;hello  word&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;hello&quot;</span> + str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello1</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">           System.out.println(args[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">           System.out.println(args[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;g</span><br><span class="line">&gt;f</span><br><span class="line">&gt;fg</span><br></pre></td></tr></table></figure></blockquote><p><strong>增删改 UPDATE 针对于user_table的通用化操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo：通用的增删改操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql, Object ...args)</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCutils.getConnection();</span><br><span class="line">            <span class="comment">//2.预编译sql语句，返回PreparedStatement实例</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//3.填充占位符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length;i++)&#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.执行sql操作</span></span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭Statement和Connection</span></span><br><span class="line">            JDBCutils.closeResuorses(conn,ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>SELECT</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo:查询操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCutils.getConnection();</span><br><span class="line">            <span class="comment">//2.预编译sql语句，返回PreparedStatement实例</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from user where user=?&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//3.填充占位符</span></span><br><span class="line">            ps.setObject(<span class="number">1</span>,<span class="string">&quot;ZHA&quot;</span>);</span><br><span class="line">            <span class="comment">//4.执行sql操作,并且返回结果集</span></span><br><span class="line">            ResultSet resultSet = ps.executeQuery();</span><br><span class="line">            <span class="comment">//5.处理结果集</span></span><br><span class="line">            <span class="keyword">if</span>(resultSet.next())&#123;<span class="comment">//判断结果集下一条是否有数据，如果有，获取字段值</span></span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                String user = resultSet.getString(<span class="number">2</span>);</span><br><span class="line">                String password = resultSet.getString(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//                System.out.println(&quot;id=&quot;+id+&quot;,user=&quot;+user+&quot;,password=&quot;+password);</span></span><br><span class="line">                User user1 = <span class="keyword">new</span> User(id,user,password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.关闭Statement和Connection</span></span><br><span class="line">            JDBCutils.closeResuorses(conn,ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>ORM编程思想</strong></p><p>一个表对应一个Java类</p><p>表中的一条记录对应一个对象</p><p>一个字段对应一个属性</p><p><img src="/Users/boxizhou/Desktop/md/img/Java%E5%92%8Csql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E8%A1%A8.png" alt="Java和sql数据类型对应表"></p></blockquote><p><strong>SELECT 针对于user_table表的通用化操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo:查询操作通用化</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommonSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from user_table where user=?&quot;</span>;</span><br><span class="line">        User myUser = commonSelect(sql,<span class="string">&quot;ZHA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span>+myUser.getId()+<span class="string">&quot;,user=&quot;</span>+myUser.getUser()+<span class="string">&quot;,password=&quot;</span>+myUser.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">commonSelect</span><span class="params">(String sql,Object ...args)</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCutils.getConnection();</span><br><span class="line">            <span class="comment">//2.预编译sql语句，返回PreparedStatement实例</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//3.填充占位符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length; i++)&#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.执行sql操作,并且返回结果集</span></span><br><span class="line">            resultSet = ps.executeQuery();</span><br><span class="line">            <span class="comment">//5.处理结果集</span></span><br><span class="line">                <span class="comment">//获取结果集的元数据(metaData,元数据，即&quot;修饰数据的数据&quot;</span></span><br><span class="line">            ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line">                <span class="comment">//通过metaData获取结果集列数（字段数）</span></span><br><span class="line">            <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(resultSet.next())&#123;<span class="comment">//判断结果集下一条是否有数据，如果有，获取字段值</span></span><br><span class="line"></span><br><span class="line">                User user2 = <span class="keyword">new</span> User();</span><br><span class="line">                <span class="comment">//处理一行结果集中的每一列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++)&#123;</span><br><span class="line">                    Object columnValue = resultSet.getObject(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取每一列的列名（字段名）</span></span><br><span class="line">                    String columnName = metaData.getColumnName(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//todo:难点。给user对象对应字段的属性赋值（通过反射***</span></span><br><span class="line">                    Field field = User.class.getDeclaredField(columnName);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(user2,columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> user2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.关闭Statement和Connection</span></span><br><span class="line">            JDBCutils.closeResuorses(conn,ps,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 NoSuchFeildException ，即数据库中列名和 JavaBean 不一样</p><p>![截屏2021-03-31 下午10.19.22](/Users/boxizhou/Desktop/md/img/截屏2021-03-31 下午10.19.22.png)</p><p>此时可以<strong>在结果集中给列取别名</strong></p><p>举个例子：</p><p>数据库中列名为<code>order_id</code>,但是Java类属性是<code>orderId</code>,直接反射会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id orderId,order_name oderName, order_date orderDate</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">&#x27;order&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>order表中列名本来是 “<code>order_id</code>”,但是返回的结果集中字段却为 “<code>orderId</code>”</p><p><strong>不过还没结束</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取每一列的列名（字段名）</span></span><br><span class="line">                    String columnName = metaData.getColumnName(i + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这一条代码是<em>直接从数据库中读列名</em>，我们<strong>要获取列的“别名”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取每一列的列名（字段名）</span></span><br><span class="line">                    String columnName = metaData.getColumnLable(i + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>getColumnLable()</code>可以从结果集中获取列的别名,没有别名时就是原名。</p></blockquote><p><strong>小结</strong></p><p>![截屏2021-03-31 下午10.32.56](/Users/boxizhou/Desktop/md/img/截屏2021-03-31 下午10.32.56.png)</p><p><strong>SELECT针对不同表的通用查询操作</strong></p><h6 id="大的要来了"><a href="#大的要来了" class="headerlink" title="大的要来了"></a>大的要来了</h6><p>针对所有表的通用化主要就是类的反射、泛型使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对所有表的通用化主要就是类的反射、泛型使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//todo:查询操作针对不同表的通用化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommonSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select id,user,password from user_table where id&gt;?&quot;</span>;</span><br><span class="line">        ArrayList&lt;User&gt; users = commonSelect(User.class,sql,<span class="number">1</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">commonSelect</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span></span>&#123;<span class="comment">//泛型参数</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCutils.getConnection();</span><br><span class="line">            <span class="comment">//2.预编译sql语句，返回PreparedStatement实例</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//3.填充占位符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length; i++)&#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.执行sql操作,并且返回结果集</span></span><br><span class="line">            resultSet = ps.executeQuery();</span><br><span class="line">            <span class="comment">//5.处理结果集</span></span><br><span class="line">            <span class="comment">//获取结果集的元数据(metaData,元数据，即&quot;修饰数据的数据&quot;</span></span><br><span class="line">            ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line">            <span class="comment">//通过metaData获取结果集列数（字段数）</span></span><br><span class="line">            <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line">              <span class="comment">//创建ArrayList存储对象</span></span><br><span class="line">            ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;<span class="comment">//判断结果集下一条是否有数据，如果有，获取字段值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                User user2 = new User();</span></span><br><span class="line">                T t = clazz.newInstance();</span><br><span class="line">                <span class="comment">//处理一行结果集中的每一列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++)&#123;</span><br><span class="line">                    <span class="comment">//获取这一列的内容</span></span><br><span class="line">                    Object columnValue = resultSet.getObject(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取每一列的列名（字段名）</span></span><br><span class="line">                    String columnName = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//todo:难点。给user对象对应字段的属性赋值（通过反射***</span></span><br><span class="line">                    Field field = User.class.getDeclaredField(columnName);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(t,columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.关闭Statement和Connection</span></span><br><span class="line">            JDBCutils.closeResuorses(conn,ps,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>两种思想<ul><li>面向接口编程</li><li>ORM思想<ul><li>一个数据表对应一个Java类</li><li>一条记录对应一个Java对象</li><li>一个字段对应Java类的一个属性</li></ul></li></ul></li><li>两种技术<ul><li>JDBC结果集元数据<ul><li>获取列数：<code>getColumnCount()</code></li><li>获取列的别名<code>getColumnLable()</code></li></ul></li><li><strong>反射</strong>：创建指定类的对象，给对象的属性进行查改</li></ul></li></ul><h4 id="三、PreparedStatement操作blob类型数据"><a href="#三、PreparedStatement操作blob类型数据" class="headerlink" title="三、PreparedStatement操作blob类型数据"></a>三、PreparedStatement操作blob类型数据</h4><blockquote><p>关于blob类型</p><p>![截屏2021-04-01 下午7.32.08](/Users/boxizhou/Desktop/md/img/截屏2021-04-01 下午7.32.08.png)</p></blockquote><p><strong>Blob INSERT</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//todo：INESERT</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blobInsertTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection conn = JDBCutils.getConnection();</span><br><span class="line">        String sql = <span class="string">&quot;insert into photo_table(id,name,photo) values(?,?,?)&quot;</span>;</span><br><span class="line">        PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        ps.setObject(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        ps.setObject(<span class="number">2</span>,<span class="string">&quot;ZHA&quot;</span>);</span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;/Users/boxizhou/Desktop/TsetPic.png&quot;</span>));</span><br><span class="line">        ps.setBlob(<span class="number">3</span>,is);</span><br><span class="line"></span><br><span class="line">        ps.execute();</span><br><span class="line"></span><br><span class="line">        JDBCutils.closeResuorses(conn,ps);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Blob SELECT</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="comment">//todo:SELECT</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blobSelectTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Connection conn = <span class="keyword">null</span>;</span><br><span class="line">       PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">       FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">       InputStream is = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           conn = JDBCutils.getConnection();</span><br><span class="line">           String sql = <span class="string">&quot;select id,name,photo from photo_table where id=?&quot;</span>;</span><br><span class="line">           ps = conn.prepareStatement(sql);</span><br><span class="line">           ps.setObject(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           ResultSet resultSet = ps.executeQuery();</span><br><span class="line">           <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">               <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">               String name = resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">               <span class="comment">//将Blob类型文件保存在本地</span></span><br><span class="line">               Blob photo = resultSet.getBlob(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">               is = photo.getBinaryStream();</span><br><span class="line">               fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/boxizhou/Desktop/PicFromBlob.png&quot;</span>);</span><br><span class="line">               <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">               <span class="keyword">int</span> len;</span><br><span class="line">              <span class="comment">//循环读流输出到文件</span></span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                   len = is.read(buffer);</span><br><span class="line">                   fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">                   <span class="keyword">if</span>(len &lt; <span class="number">1024</span>)&#123;<span class="comment">//当流不能装满buffer，视为读完</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception throwables) &#123;</span><br><span class="line">           throwables.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           is.close();</span><br><span class="line">           fos.close();</span><br><span class="line">           JDBCutils.closeResuorses(conn, ps);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习MySql数据库-和-JDBC&quot;&gt;&lt;a href=&quot;#学习MySql数据库-和-JDBC&quot; class=&quot;headerlink&quot; title=&quot;学习MySql数据库 和 JDBC&quot;&gt;&lt;/a&gt;学习MySql数据库 和 JDBC&lt;/h1&gt;&lt;h2 id=&quot;关系型数据</summary>
      
    
    
    
    
    <category term="Java Learning" scheme="http://example.com/tags/Java-Learning/"/>
    
  </entry>
  
  <entry>
    <title>端口映射</title>
    <link href="http://example.com/2021/04/12/DAY1%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"/>
    <id>http://example.com/2021/04/12/DAY1%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</id>
    <published>2021-04-12T11:18:40.000Z</published>
    <updated>2021-10-11T07:03:42.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY1-端口映射"><a href="#DAY1-端口映射" class="headerlink" title="DAY1:端口映射"></a>DAY1:端口映射</h1><h3 id="0x01-TCP-IP协议"><a href="#0x01-TCP-IP协议" class="headerlink" title="0x01 TCP/IP协议"></a>0x01 TCP/IP协议</h3><p>网络分为5层，从上到下分别为<strong>应用层</strong>、<strong>运输层</strong>、<strong>网络层</strong>、<strong>链路层</strong>和物理层，</p><p>上层需要下层服务的支持。在软件层面上，我们主要研究前四层而不考虑信息在物理层上如何传输。</p><p>应用通过API将信息丢给应用层，然后依次传输到下层，直到物理层以二进制的方式传输，到达目的地后再由下层向上层传输，回到应用层去。我们主要研究信息在软件层面（前4层）的传输，而不考虑在物理层如何传输。</p><p>以QQ程序为例，computer A 发送的消息要经过4层处理，每经过一层，该层就会对你的信息进行包装。包装的大致方式是在原有信息上添加报文首部（header）补充信息，就像写完一封信要在信封上添加发件人、收件人信息一样。其中应用层会添加端口信息（port）；传输层添加TCP/UDP信息；网络层添加IP地址信息（包括源端口和目的端口）；链路层添加MAC信息。同样地，computer B 收到报文后，相应的层会自下而上对报文进行解析，找到对应的 MAC 、IP 、port，然后找到目标电脑和目标程序，对方就能收到你的信息了。</p><p><img src="/DAY1%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><p>但在现实中，两台电脑并不能直接传输信息。信息需要经由路由器、交换机的转发处理，才能到达目的电脑。<img src="/DAY1%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B61.png" alt="未命名文件1"></p><p>路由器通过解析目的IP，对信息进行转发,</p><p>其中路由器的网络协议中只有网络层、链路层和物理层，交换机只有链路层和物理层。这意味着路由器只能将信息解析到 IP 的程度，不过这足够路由器对信息进行转发了。</p><h3 id="0x02-外网IP和内网IP"><a href="#0x02-外网IP和内网IP" class="headerlink" title="0x02 外网IP和内网IP"></a>0x02 外网IP和内网IP</h3><h4 id="外网和内网："><a href="#外网和内网：" class="headerlink" title="外网和内网："></a>外网和内网：</h4><p>简单来说，路由器外属于公网，而路由器内就是内网。</p><p>由于ipv4协议的ip地址有限，不能满足给每一台电脑分配单独的IP的需求。于是便有了公网IP和内网IP，同样地存在内外网端口。</p><p><code>NAT端口映射</code>实现了<strong>外网端口和内网端口之间的映射</strong>，把外网端口和内网端口进行对应。<img src="/DAY1%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B62.png" alt="未命名文件2"></p><p><strong>做过NAT端口映射后，公网端口就确定了，就可以通过公网连接工作室机子瞭！</strong></p><h3 id="0x03-实践："><a href="#0x03-实践：" class="headerlink" title="0x03 实践："></a>0x03 实践：</h3><h4 id="TODO：从工作室外ssh到node01，执行ifconfig、arp命令。"><a href="#TODO：从工作室外ssh到node01，执行ifconfig、arp命令。" class="headerlink" title="TODO：从工作室外ssh到node01，执行ifconfig、arp命令。"></a>TODO：从工作室外ssh到node01，执行ifconfig、arp命令。</h4><p>已知机子公网 IP:Port 为 202.115.13.201:12222 ,执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DAY1-端口映射&quot;&gt;&lt;a href=&quot;#DAY1-端口映射&quot; class=&quot;headerlink&quot; title=&quot;DAY1:端口映射&quot;&gt;&lt;/a&gt;DAY1:端口映射&lt;/h1&gt;&lt;h3 id=&quot;0x01-TCP-IP协议&quot;&gt;&lt;a href=&quot;#0x01-TCP-IP协</summary>
      
    
    
    
    
    <category term="Network Learning" scheme="http://example.com/tags/Network-Learning/"/>
    
  </entry>
  
</feed>
